# 1.1 The Elements of Programming

Thus, when we describe a language, we should pay particular attention to the
means that the language provides for combining simple ideas to form
more complex ideas. Every powerful language has three mechanisms
for accomplishing this:

- **primitive expressions**, which represent the simplest entities the language is concerned with,
  > 原始表达式，表示语言中最简单的实体；
- **means of combination**, by which compound elements are built from simpler ones, and
  > 结合的方法，如何将简单的表达式结合，以得到复杂的元素；
- **means of abstraction**, by which compound elements can be named and manipulated as units.
  > 抽象的方法，复合元素可以被命名并作为单元使用。

two kinds of elements: procedures and data.

**data is "stuff" we want to manipute, and procedures are descriptions of the tules for maniputing the data.**

## 1.1.1 Expressions

some expressions in Lisp:

```Scheme
(+ 137 349) -> 486

(- 1000 334) -> 666

(* 5 99) -> 495

(/ 10 5) -> 2

(+ 2.7 10) -> 12.7
```

the leftmost element in the list is called the _operator_, and the other elements are called _operands_.

the convention of placing the operator to the left of the operands is known as _prefix_ notation.

Prefix notation has several advantages, one of them is that it can accommodate procedures that may take an arbitraty number of arguments. For example:

```Scheme
(+ 21 35 12 7) -> 75

(* 25 4 12) -> 1200
```

A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be nested, that is, to have combinations whose elements are themselves combinantions. 即组合之中有组合.

```Scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) -> 57
```

"Lisp programmers know the value of everything but the cost of nothing"

## 1.1.2 Naming and the Environment

In the Lisp dialect of Lisp, we name things with define: `(define size 2)`

```Scheme
(define pi 3.14159)
(define radius 10)
(define circumference (* 2 pi radius))

circumference
```

define is our language’s simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations, such as the circumference computed above.

It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the environment (more precisely the global environment).

## 1.1.3 Evaluating Combinations

To evaluate a combination, dp the following:

1. Evaluate the subexpressions of the combination.
2. Apply the procedure that is the value of the leftmost subexpression(the operator) to the arguments that are the values of the other subexpressions(the operands).

This evaluation rule given above does not handle definitions. For instance, evaluating (define x 3) does not apply define to two arguments, one of which is the value of the symbol x and the other of which is 3, since the purpose of the define is precisely to associate x with a value. (That is, (define x 3) is not a combination.)

## 1.1.4 Compound Procedures

Now we will learn about _procedure definitions_, a much more powerful abstraction technique by which a compound operation can be given a name and then referred to as a unit.

```Scheme
(define (square x) (* x x))
```

The general form of a procedure definition is:

```Scheme
(define (<name> <formal parameters>)
    <body>)
```

## 1.1.5 The Substitution Model for Procedure Application

1. The purpose of the substitution is to help us think about procedure application, not to provide a description of how the interpreter really works. Typical interpreters do not evaluate procedure applications by manipulating the text of a procedure to substitute values for the formal parameters. In practice, the "substitution" is accomplished by using a local environment for the formal parameters. We will discuss this more fully in Chapter 3 and Chapter 4 when we examine the implementation of an interpreter in detail.
2. Over the course of this book, we will present a sequence of increasingly elaborate models of how interpreters work, culminating with a complete implementation of an interpreter and compiler in Chapter 5. The substitution model is only the first of these models—a way to get started thinking formally about the evaluation process. In general, when modeling phenomena in science and engineering, we begin with simplified, incomplete models As we examine things in greater detail, these simple models become inadequate and must be replaced by more refined models. The substitution model is no exception. In particular, when we address in Chapter 3 the use of procedures with "mutable data," we will see that the substitution model breaks down and must be replaced by a more complicated model of procedure application.

## 1.1.6 Conditional Expressions and Predicates

_cond_: a special form

```Scheme
(define (abs x)
    (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0> (- x)))
        ))
```

_general form_：

```Scheme
(cond (<p1> <e1>)
        (<p2> <e2>)
        (<p3> <e3>)
        ...
        (<p_n> <e_n>))
```

_if_:

```Scheme
(if <predicate> <consequent> <alternative>)
```

_and_:

```Scheme
(and <e1> ... <e_n>)
```

_or_:

```Scheme
(or <e1> ... <e_n>)
```

_not_:

```Scheme
(not <e>)
```

## 1.1.7 Example: Square Roots by Newton's Method

As a case in point, consider the problem of computing square roots. We can define the square-root function as

$$
\sqrt{x} = the \;\; y \;\; such\;\; that \;\; y\ge 0 \;\; and \;\; y^2 = x
$$

The contrast between function and procedure is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge.

In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usually concerned with imperative(how to) descriptions.20

implemention sqrt:

```Scheme
(define (sqrt x)
    (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
    (if (good-enough? guess x) guess)
    (sqrt-iter (improve guess x) x))

(define (improve guess x)
    (average guess (/ x guess)))

(define (average x y) (/ (+ x y) 2))

; Modify version
(define (good-enough? guess x)
    (< (abs (- guess (improve guess x))) 0.001))
```

## 1.1.8 Procedures as Black-Box Abstractions

So a procedure definition should be able to suppress detail. The users of the procedure may not have written the procedure themselves, but may have obtained it from another programmer as a black box. A user should not need to know how the procedure is implemented in order to use it.

### local names

If the parameters were not local to the bodies of their respective
procedures, then the parameter x in square could be confused with the parameter x in good-enough?, and the behavior of good-enough? would depend upon which version of square we used. Thus, square would not be the black box we desired.

The meaning of a procedure definition is unchanged if a bound variable is consistently renamed throughout the definition.

### Internal definitions and block structure

The formal parameters of a procedure are local to the body of the procedure.

We allow a procedure to have internal definitions that are local to that procedure. For example, in the square-root problem we can write:

```Scheme
(define (sqrt x)
    (define (good-enough? guess x)
        (< (abs (- guess (improve guess x))) 0.001))

    (define (improve guess x)
        (average guess (/ x guess)))

    (define (sqrt-iter guess x)
        (if (good-enough? guess x) guess)
        (sqrt-iter (improve guess x) x))

    (define (average x y) (/ (+ x y) 2))

    (sqrt-iter 1.0 x))
```

this called _block structure_.
