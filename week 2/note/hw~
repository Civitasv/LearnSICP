#lang simply-scheme

(define (product fn a next b)
        (if (> a b)
            1
            (* (fn a) (product fn (next a) next b))))


(define (factorial n)
  (product (lambda (x) x) 1 (lambda (x) (+ 1 x)) n))


(factorial 3)

(define (pi terms)
  (* 4 (product (lambda (x) (/ (* (- x 1) (+ x 1))
                               (* x x)))
                3
                (lambda (x) (+ x 2))
                terms)))

(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a) (accumulate combiner null-value term (next a) next b))))

(define (sum fn a next b)
  (accumulate + 0 fn a next b))

;(define (product fn a next b)
 ; (accumulate * 1 fn a next b))

(define (filtered-accumulate PRED combiner null-value term a next b)
  (if (> a b)
      null-value
      (if (PRED a)
          (combiner (term a) (filtered-accumulate PRED combiner null-value term (next a) next b))
          (filtered-accumulate PRED combiner null-value term (next a) next b))
      ))

;(define (sum-square-prime a b)
 ; (filtered-accumulate prime? + 0 (lambda (x) (* x x)) a (lambda (x) (+ x 1)) b))

;(define (product-positive n)
 ; (filtered-accumulate (lambda (x) (= 1 (gcd x n))) * 1 (lambda (x) x) 1 (lambda (x) (+ 1 x)) n))

